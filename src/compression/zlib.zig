//! zlib (RFC 1950) wrapper around DEFLATE

const std = @import("std");
const Allocator = std.mem.Allocator;
const flate = std.compress.flate;

pub const CompressionStrategy = enum { default, filtered, huffman_only, rle };

/// Compresses data using zlib format.
pub fn compress(gpa: Allocator, data: []const u8, options: flate.Compress.Options, strategy: CompressionStrategy) ![]u8 {
    var aw = std.Io.Writer.Allocating.init(gpa);
    defer aw.deinit();

    // PNG and other users might benefit from some initial capacity
    try aw.ensureTotalCapacity(data.len / 2 + 64);

    const buffer = try gpa.alloc(u8, flate.max_window_len);
    defer gpa.free(buffer);

    if (strategy == .huffman_only) {
        var huff = try flate.Compress.Huffman.init(&aw.writer, buffer, .zlib);
        try huff.writer.writeAll(data);
        try huff.writer.flush();
    } else {
        const opts = mapOptions(options, strategy);
        var compressor = try flate.Compress.init(&aw.writer, buffer, .zlib, opts);
        try compressor.writer.writeAll(data);
        try compressor.writer.flush();
    }

    return aw.toOwnedSlice();
}

/// Decompress zlib data.
/// Returns an owned slice that must be freed by caller.
pub fn decompress(gpa: Allocator, zlib_data: []const u8, max_output_bytes: usize) ![]u8 {
    var in_stream = std.Io.Reader.fixed(zlib_data);
    const buffer = try gpa.alloc(u8, flate.max_window_len);
    defer gpa.free(buffer);

    var decompressor = flate.Decompress.init(&in_stream, .zlib, buffer);

    var aw = std.Io.Writer.Allocating.init(gpa);
    errdefer aw.deinit();

    // If we have a hint about output size, use it
    if (max_output_bytes != std.math.maxInt(usize)) {
        try aw.ensureTotalCapacity(max_output_bytes);
    }

    _ = try decompressor.reader.streamRemaining(&aw.writer);

    const result = try aw.toOwnedSlice();
    if (result.len > max_output_bytes) {
        gpa.free(result);
        return error.OutputLimitExceeded;
    }

    return result;
}

fn mapOptions(options: flate.Compress.Options, strategy: CompressionStrategy) flate.Compress.Options {
    var opts = options;
    switch (strategy) {
        .default => {},
        .filtered => {
            opts.chain = @min(opts.chain, 16);
            opts.nice = @min(opts.nice, 32);
        },
        .rle => {
            opts.chain = @min(opts.chain, 8);
        },
        .huffman_only => {
            // Handled separately by using Huffman-only compressor
        },
    }
    return opts;
}

test "zlib round trip" {
    const allocator = std.testing.allocator;
    const original_data = "Hello, zlib compression test for PNG!";
    const compressed = try compress(allocator, original_data, .default, .default);
    defer allocator.free(compressed);
    const decompressed = try decompress(allocator, compressed, original_data.len);
    defer allocator.free(decompressed);
    try std.testing.expectEqualSlices(u8, original_data, decompressed);
}

test "zlib header validation" {
    const allocator = std.testing.allocator;
    const test_data = "Test";
    const compressed = try compress(allocator, test_data, .level_1, .default);
    defer allocator.free(compressed);
    try std.testing.expect(compressed.len >= 6);
    const cmf = compressed[0];
    try std.testing.expectEqual(@as(u8, 8), cmf & 0x0F);
    const header_check = (@as(u16, compressed[0]) << 8) | compressed[1];
    try std.testing.expectEqual(@as(u16, 0), header_check % 31);
}

test "zlib compression levels" {
    const allocator = std.testing.allocator;
    const base = "The quick brown fox jumps over the lazy dog. ";
    const test_data = blk: {
        var data: std.ArrayList(u8) = .empty;
        defer data.deinit(allocator);
        for (0..10) |_| {
            try data.appendSlice(allocator, base);
        }
        break :blk try data.toOwnedSlice(allocator);
    };
    defer allocator.free(test_data);
    const levels = [_]flate.Compress.Options{ .level_1, .level_3, .level_6, .level_9 };
    var sizes: [levels.len]usize = undefined;
    for (levels, 0..) |level, i| {
        const compressed = try compress(allocator, test_data, level, .default);
        defer allocator.free(compressed);
        sizes[i] = compressed.len;
        const decomp = try decompress(allocator, compressed, test_data.len);
        defer allocator.free(decomp);
        try std.testing.expectEqualSlices(u8, test_data, decomp);
    }
    // Sizes should generally decrease or stay same as level increases
    try std.testing.expect(sizes[0] >= sizes[levels.len - 1]);
}

test "zlib interoperability" {
    const allocator = std.testing.allocator;
    const hello = "Hello";

    // 1. Test decompress with known valid zlib payload (generated by python zlib)
    // Hex: 78 01 f3 48 cd c9 c9 07 00 05 8c 01 f5
    // Header: 78 01 (default)
    // Data: f3 48 cd c9 c9 07 00 (deflate of "Hello")
    // Checksum: 05 8c 01 f5 (Adler32 of "Hello")
    const valid_payload = [_]u8{ 0x78, 0x01, 0xf3, 0x48, 0xcd, 0xc9, 0xc9, 0x07, 0x00, 0x05, 0x8c, 0x01, 0xf5 };

    const decompressed = try decompress(allocator, &valid_payload, hello.len);
    defer allocator.free(decompressed);
    try std.testing.expectEqualSlices(u8, hello, decompressed);

    // 2. Test verify checksum generation matches standard
    // Adler32("Hello") = 0x058c01f5
    const compressed = try compress(allocator, hello, .level_1, .default);
    defer allocator.free(compressed);

    // Checksum is at the last 4 bytes
    const expected_checksum: u32 = 0x058c01f5;
    const actual_checksum = std.mem.readInt(u32, compressed[compressed.len - 4 ..][0..4], .big);

    try std.testing.expectEqual(expected_checksum, actual_checksum);
}
